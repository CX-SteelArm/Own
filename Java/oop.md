## oop methods

### URL(Unified Modeling Language)

“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。

几种关系：

1. -------> 依赖关系，A中某个方法的参数是B类型，或者某个方法中用到了B类型的参数
2. ———————— 关联关系，可以用实线或者实心箭头线表示，A中有B类型的成员
3. ——————<> 聚合关系(has) 如 Teather ——————<> University
4. ——————<|> 组合关系(contain) 如 Month ——————<|> Head（建造者模式）
5. ———————|> 泛化关系(is) 如 Student ——————|> Person（父子类之间的关系就是泛化关系）
6. -------|> 实现关系，对接口的实现

### 设计原则

- 开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；
- 里氏替换原则告诉我们不要破坏继承体系；（子类不要完全重写父类的方法，应该在调用父类方法的基础上实现）
- 依赖倒置原则告诉我们要面向接口编程；其核心思想是：要面向接口编程，不要面向实现编程。
- 单一职责原则告诉我们实现类要职责单一；
- 接口隔离原则告诉我们在设计接口的时候要精简单一；
- 迪米特法则告诉我们要降低耦合度；（不该让类知道的，不让它知道）
- 合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。（桥接模式）

## 一句话概括

创建型模式：关注点是“怎么创建对象”，主要特点是将对象的创建与使用分离

另外一个主要的特点是不采用new产生新对象，而是通过类的某种方法间接产生

### 单例模式

类通过静态方法返回唯一的实例，实现方法分为懒汉式和饿汉式

### 原型模式

通过复制一个既有对象的形式创建新对象，Java的实现需要类实现clone方法

### 简单工厂模式

一个工厂，如果条件为A，生产a产品；如果条件为B，生产b产品

### 工厂方法模式

产生AA工厂的实例，（调用工厂的方法）生产a产品；产生BB工厂的实例，生产b产品

### 抽象工厂模式

格力可以生产空调和口罩，分别叫格力牌空调和格力牌口罩；美的可以生产空调和口罩，分别叫美的牌空调和美的牌口罩。

格力和美的都应该实现公司接口（抽象工厂），格力牌空调和美的牌空调都应该实现空调接口，格力牌口罩和美的牌口罩都应该实现口罩接口。

### 建造者模式

产品由x,y,z三部分组成，公司A和B分别有实现三个部分的方法，它们都派生自虚拟的公司类，经纪人I负责调用公司类的方法，完成产品制造。

----------------

结构型模式：关注如何将类和对象布局成更大的结构，它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。对象模式比类模式有更大的灵活性。

### 代理模式

经纪人类存在一个明星成员，代理对明星的访问，**一般两者暴露同样的对外接口**

### 适配器模式

分为类结构型模式和实例结构型模式两种。

类结构型模式：适配器是被适配者的子类，新增加了一些方法来访问被适配者。

实例结构型模式：适配器中有被适配者成员，通过增加一些方法实现对被适配者的访问，有点类似代理模式。

### 桥接模式

有8种颜色和3中动力方式的汽车要生产，先抽象出颜色类和动力类，分别实例化后组合成汽车实例

    "将抽象与实现分离，使它们可以独立变化"
    继承使得子类存在一些父类无用的属性和方法，整套系统变得臃肿。
    在设计模式中一个重要原则是优先使用组合/聚合，而不是继承。

### 装饰模式

人吃饭 -> 把人传给"狼吞虎咽装饰器" -> 装饰器给人添加一些吃饭动作

    在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式
    通过使用不同装饰类及这些装饰类的排列组合，可以实现不同效果
    有点类似代理模式

### 外观模式

A系统由a,b,c,d作为子系统作支撑，但是a,b,c,d子系统之间有很多联系，相互缠结，此时可以在A类中分别声明a,b,c,d类型成员变量，把依赖关系内部消化，A系统暴露给外界的还是简单的接口

    对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。

### 享元模式

车间（享元工厂）有A机器和B机器（具体享元角色），使用者可以拿自己的磁盘（非享元角色）去车间使用A或者B机器生产零件。

    享元使得只需创建改变的角色，而不需创建可以共享的部分，节省了空间。

    享元工厂使用HashMap、ListArray等数据结构存储了具体享元角色，然后以某种规则进行调用

### 组合模式

树干和树枝

    三种角色：抽象构件、树枝构件、树叶构件，树枝构件作为容器放置树叶构件，它们都实现一个统一的接口
    比如树干和树枝都实现“摇动”接口，当树干调用“摇动”方法时，不光其本身可以“摇动”，其管理的所有树叶也都可以“摇动”

----------------

行为型模式：用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。

### 模板方法模式

比较常用的模式，一个算法分为ABCD四个步骤，其中ACD相对固定，B可以依据不同场景变更，则先定义虚拟父类Algo，其中定义虚函数B，然后其子类去实现B方法

### 策略模式

比较常用的模式，可以将一段分支差异不大的复杂算法逻辑简化为通过定义几个不同的分支类实现，从而达到封装的目的；当策略较多时可以选择使用策略工厂模式，工厂内定义一个策略容器，对不同场景可以取出不同的算法应用在程序中。

### 命令模式

一个命令类对应一个具体接收者，命令调用者包含一个命令成员，可以通过改变成员，触发同样的方法得到调用执行者的功能。

### 职责链模式

一件任务，经过A-B-C-D四个角色依次处理，每个角色只负责自己的部分，不管其他人的东西。

### 状态模式

类似状态机的操作 `public void press(String btn) { state.changeState(btn, this);}`

环境类将自己传给状态，状态根据目前环境所处状态决定如何进行转换。

### 备忘录模式

三个角色：发起人、管理者和备忘录，发起人在状态发生变化时，生成一个新的备忘录实例，并且调用管理者的方法将该实例置于管理者内部，管理者可以调用自己的方法来恢复某种状态

### 中介者模式

中介者管理了所有的卖方和买方，可以转发他们的消息，也可以对消息进行加工
