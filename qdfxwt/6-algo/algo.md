问题集合：

1. 二分法经典问题
2. 快速排序经典问题
3. 队列模拟栈，栈模拟队列，有最小值的栈结构
4. 斐波那契额问题
5. 全排列
6. 贪心算法，联机算法
7. 树的遍历问题
8. 链表问题
9. 排序方法汇总
10. 抽样算法
11. 字符串相加、字符串相乘
12. BFS和DFS，Prime算法，dijkstra
13. 高级数据结构，跳跃表，B树，B+树，红黑树，二项队列，斐波那契额队（了解）
14. 手写堆

问题解答：

#### 二分法经典问题

从已排序的数组中解决某个问题，如：
* 旋转数组的最小值，形如345612这种叫做旋转数组，最小值显然是1; 这个问题要考虑头、中、尾相同的情况，此时退化到顺序查找
* 有序数组中k出现的次数，分别利用二分法找到开头和结尾处的k，然后依据下标求得次数

#### 快排经典问题

快排思路：19852167 =1> 19872165 =2> 12879165 =2> 12179865 =3> 12159867
1为交换中位和末位，两个指针分别从(-1和0)处出发，往前移动
`sortHelper`工具函数：输入数列、开头和结尾的索引，排序已有数列，**返回中间那个数的索引**

经典问题：

* 寻找数列中最小的k个数，递归运用`sortHelper`工具函数，不断压缩空间直到索引为k，这是一个O(n)解法
  对于很大的数组，维持一个大顶堆，堆内包含最小的k个数，时间复杂度为O(nlogk)
  构造堆：O(n) 第一层不需调整，此后逐元素调整
  堆的增加和删除：O(log(k))

* 数组中有一个数出现的次数大于一半，找到它。
  有几种方法：
  一是直接找，O(n)需要额外空间
  二是联机算法，O(n)无需额外空间，比较巧妙
  三是利用`sortHelper`工具函数，O(n)无需额外空间，但是很冗杂

#### 斐波那契额问题

类似问题是上楼梯问题、2x1矩形拼接问题

解法有几种：
* 尾递归，最差解法
* 遍历，保存索引，O(n)
* 化归成矩阵的方法{f(n+1), f(n)} = [[1,1], [1,0]] * {f(n), f(n-1)}, 化为矩阵求平方，O(logn)
* 直接用数学方法求得矩阵n次方，得到通项公式，O(1)

#### 树的遍历问题

遍历方式：先序遍历、后序遍历、中序遍历
方法：都有递归法和非递归法
先序遍历的非递归法是把它的右儿子加入栈中，然后逐步进行操作
中序遍历的非递归法是把它自己加入栈中
后序遍历的非递归法是把它的左儿子加入栈中，得到结果后翻转即可

* 求树的深度，遍历问题，D(t) = 1 + max{D(t).left, D(t).right}
* 求树上的路径（一条路径所有元素和为n），遍历问题，从顶点向下逐步累积查找，知道和为n且是叶子结点，输出结果
  findSumRoot(node, target, cum=[])，这个问题cum是用于存储值的数组，可以复用
* 树的镜像，一个先序遍历的问题
* 根据先序遍历和后序遍历构造树、判断后序遍历序列之类的问题：利用遍历的性质，先序遍历结果的树根在最开头，后序遍历的树根在最末尾，中序遍历树根左边的数是左子树，右边的数是右子树

#### 队列模拟栈，栈模拟队列，有最小值的栈结构

栈模拟队列：出的时候比较麻烦，要倒灌
队列模拟栈：每次都要互相倒灌，更麻烦
有最小值的栈结构：栈中只存放与当下最小值的差值，有一个最小值的字段不断更新

#### 排序方法汇总

冒泡：比较相邻两个元素，如果前一个比后一个大就交换两个，O(n*n)
选择：每次找到最小的那个元素，将它与待排的位置交换，O(n*n)
插入：每次取出一个元素，从后到前遍历这个元素之前的元素，把它插入到合适的位置，O(n*n)
希尔排序：插入排序的发展，设定一个序列，比如8,4,2,1这种序列，每次间隔指定个元素进行插入排序，O(n^1.3)
  Sedgewick: 平均复杂度O(n^7/6)
  Hibbard: 平均复杂度O(n^5/4)
堆排序：构建堆O(n),排序O(nlogn)
快速排序：略
基数排序：先按个位放到指定位置，然后整理得到序列；接着按十位数操作，以此类推。
归并排序：分治法，略

#### 链表问题

* 翻转链表，这种问题需要关注原来的头和它的儿子之间要切断联系，否则会发生无线循环
* 从后到前打印链表，可用栈或者递归的方法，都行
* 输出倒数第k个节点，双指针法，注意最后一起走时候的循环条件：while(p1.next) { p1=p1.next; p2=p2.next; }
* 合并两个排序链表，双指针法

#### 随机算法，抽样

输入n个数，得到随机的n个数
* 经典洗牌算法，先从第0至第n-1个数中随机取一个，然后将它与最后一个数交换位置，接着从第0至第n-2个数中随机取一个...
* 蓄水池算法

#### 一般问题解法

1. 二分法，适合解决有序排列查找的问题
2. 双指针法，滑窗法
3. 动态规划，其实是对递归问题的存值优化，以空间换时间
4. 递归法，适合对全排列问题进行分析和求解
5. 贪心法，贪心不一定总能获得最优解
6. 联机算法，一般较为巧妙
7. 分治法，分而治之，然后合而为一，归并排序就是利用这种思路
